/***************************************************************************
 *   Copyright (C) 2007 by Vincenzo Forchi`,,,   *
 *   vincenzo.forchi@elettra.trieste.it   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/


#include "interlock.h"
#include <qtango.h>
#include <QtSql>
#include "mysqlmodel.h"
#include <TLog>
#include <QMessageBox>

Interlock::Interlock(QWidget *parent) : QWidget(parent)
{
	if (QApplication::arguments().size() > 1)
		device_name = QApplication::arguments()[1];
	else
		device_name = "f/interlock/plc_ll";
	
	Config::instance()->setOverrideValuesAttributePropertyName("labels");
	
	ui.setupUi(this);
	setupDb();
	configureUi();
	createConnections();
	QTimer::singleShot(500, this, SLOT(connectTango()));
}

void Interlock::setupDb()
{
  /* connect to db */
  db = QSqlDatabase::addDatabase("QMYSQL");
  db.setHostName("srv-log-srf");
  db.setDatabaseName("intlkfermi");
  db.setUserName("ifermi");
  db.setPassword("ferm");
  if (!db.open())
	QMessageBox::critical(0, "Error", "Can't establish connection with db intlkboost on host log");

  queryType = QueryConfiguration::LastDay;
	  model = new MySqlModel();
  ui.treeLogs->setModel(model);

  readFromDb();
  dbTimer = new QTimer(this);
  connect(dbTimer, SIGNAL(timeout()), this, SLOT(readFromDb()));
  dbTimer->start(10000);
}
	
void Interlock::createConnections()
{
  	connect(ui.pushAckSelected, SIGNAL(clicked()), this, SLOT(acknowledgeSelected()));
	connect(ui.treeAlarms, SIGNAL(acknowledgeSelected()), this, SLOT(acknowledgeSelected()));
// // 	connect(ui.treeAlarms, SIGNAL(acknowledgeAll()), ui.tAckAll, SIGNAL(clicked()));
	connect(ui.pushRefresh, SIGNAL(clicked()), this, SLOT(readFromDb()));
    connect(ui.pushQueryConfiguration, SIGNAL(clicked()), this, SLOT(queryConfiguration()));
	connect(ui.cbStatSelection, SIGNAL(currentIndexChanged(int)), this, SLOT(changeStatView(int)));
	connect(ui.rbSelectMod, SIGNAL(toggled(bool)), this, SLOT(modSelected(bool)));
	connect(ui.comboAck, SIGNAL(currentIndexChanged(int)), this, SLOT(changeAckTarget(int)));
}

void Interlock::configureUi()
{
  	ui.treeAlarms->setDescriptions(getProperty("Db_alarm", "labels"));
	ui.tableStates->setDescriptions(getProperty("Stat_system", "labels"));
	ui.rbGeneral->setChecked(true);
	QStringList mods;
	for(int i = 0; i < 12; i++)
	  mods << QString("mod%1").arg(i, 2, 10, QChar('0'));
	ui.cbStatSelection->insertItems(0, mods);
}

Interlock::~Interlock()
{
}

void Interlock::connectTango()
{
	ui.treeAlarms->setPeriod(1000);
	ui.treeAlarms->setRefreshMode(POLLED_REFRESH);
	ui.treeAlarms->setSource(device_name + "/Db_alarm");
	ui.tableStates->setSource(device_name + "/Stat_system");
	ui.tAck->setTargets(device_name + QString("->Acknowledge(%1)").arg(ui.comboAck->itemData(0).toInt()));
}

void Interlock::changeAckTarget(int idx)
{
  ui.tAck->setTargets(device_name + QString("->Acknowledge(%1)").arg(ui.comboAck->itemData(idx).toInt()));
}

QStringList Interlock::getProperty(string attr, string property)
{
        QStringList temp;
	try {
		Database db;
                DbData db_data;
		db_data.push_back(DbDatum(attr));
	        db.get_device_attribute_property(device_name.toStdString(), db_data);
	        int i = 0;
                if (db_data.size())
                {
                        long nb_prop;
                        string &att_name = db_data[i].name;
                        db_data[i] >> nb_prop;
                        i++;
                        for (int k = 0; k < nb_prop; k++)
                        {
                                string &prop_name = db_data[i].name;
                                if (att_name == attr)
                                {
                                        if (prop_name == property)
                                        {
                                                vector<string> vs;
                                                if (!db_data[i].is_empty())
                                                {
                                                        db_data[i] >> vs;
							for (unsigned int ll = 0; ll < vs.size(); ll++)
								temp << QString::fromStdString(vs[ll]);
                                                }
                                        }
                                }
                                i++;
                        }
                }
	} catch (DevFailed &e) {
                Except::print_exception(e);
        }
	return temp;
}

void Interlock::acknowledgeSelected()
{
  /// //////////////////
  printf("\e[1;33m - da implementare - \e[0m\n");
  return;
  /// //////////////////
  
	QVector<double> v_attr(ui.treeAlarms->dataSize(), 0);
//	QVector<long> v_comm(ui.treeAlarms->dataSize(), 0);
	foreach (QTreeWidgetItem *it, ui.treeAlarms->selectedItems())
	{
		//qDebug() << it->text(3);
		v_attr[it->text(3).toInt()] = 1;
//		v_comm << it->text(3).toLong();
	}
	try {
		DeviceAttribute attr;
		attr.set_name("Db_alarm");
		vector<double> dati = v_attr.toStdVector();
		attr << dati;
		TUtil::instance()->findDeviceProxy(device_name)->write_attribute(attr);
	} 
	catch (DevFailed &e) 
	{
		TLog log(e);
		TUtil::instance()->addLog(log.toTimeErrlistPair(), log.formatMessage());
        QMessageBox::critical(0, "Error", log.formatMessage(log.toTimeErrlistPair()));
	}
	ui.treeAlarms->clearSelection();
}

void Interlock::queryConfiguration()
{
        QueryConfiguration win;
        win.setQueryType(queryType);
        if (queryType == QueryConfiguration::Interval)
        {
                win.setStartDateTime(begin);
                win.setStopDateTime(end);
        }

        if (win.exec() == QDialog::Accepted)
        {
                queryType = win.queryType();
                begin = win.startDateTime();
                end = win.stopDateTime();
                readFromDb();
        }
}

void Interlock::readFromDb()
{
        if (!db.isOpen())
                if (!db.open())
                {
                        QMessageBox::critical(0, "Error", "Can't establish connection with db FastInterlock on host log");
                        return;
                }

        QDateTime adesso = QDateTime::currentDateTime();
        QString query;
        unsigned int inizioRicerca;
        switch (queryType)
        {
                case QueryConfiguration::LastDay:
                        inizioRicerca = adesso.addDays(-1).toTime_t();
                        query = QString("SELECT timestamp, name, state, message FROM alarms WHERE timestamp > %1 ORDER BY timestamp DESC").arg(inizioRicerca);
                        break;
                case QueryConfiguration::LastWeek:
                        inizioRicerca = adesso.addDays(-7).toTime_t();
                        query = QString("SELECT timestamp, name, state, message FROM alarms WHERE timestamp > %1 ORDER BY timestamp DESC").arg(inizioRicerca);
                        break;
                case QueryConfiguration::LastMonth:
                        inizioRicerca = adesso.addMonths(-1).toTime_t();
                        query = QString("SELECT timestamp, name, state, message FROM alarms WHERE timestamp > %1 ORDER BY timestamp DESC").arg(inizioRicerca);
                        break;
                case QueryConfiguration::Interval:
                        query = QString("SELECT timestamp, name, state, message FROM alarms WHERE timestamp > %1 AND timestamp < %2 ORDER BY timestamp DESC").arg(begin.toTime_t()).arg(end.toTime_t());
                        break;
                case QueryConfiguration::All:
                        query = QString("SELECT timestamp, name, state, message FROM alarms ORDER BY timestamp DESC");
                        break;
                default:
                        break;
        }

        model->setQuery(query);
	model->setHeaderData(0, Qt::Horizontal, "Timestamp");
	model->setHeaderData(1, Qt::Horizontal, "Name");
	model->setHeaderData(2, Qt::Horizontal, "State");
	model->setHeaderData(3, Qt::Horizontal, "Description");

	ui.treeLogs->resizeColumnToContents(0);
	ui.treeLogs->resizeColumnToContents(1);

        QSqlError error = model->lastError();
        if (error.type() != QSqlError::NoError)
        {
                QMessageBox::critical(0, "Database Error", QString("Error reading from Db:\n") + error.text() + "\nreconnecting");
                db.close();
                if (!db.open())
                {
                        QMessageBox::critical(0, "Error", "Can't establish connection with db FastInterlock on host log");
                        return;
                }
        }
}

void Interlock::on_tabWidget_currentChanged(int idx)
{
	if (idx == 2)
	{
		readFromDb();
		dbTimer->start();
	}
	else
		dbTimer->stop();
}

void Interlock::modSelected(bool en)
{
  ui.cbStatSelection->setEnabled(en);
  if(en)
	changeStatView(ui.cbStatSelection->currentIndex()); /* will also update descriptions */
  else
  {
	ui.tableStates->setSource(device_name  + "/Stat_system");
	ui.tableStates->setDescriptions(getProperty("Stat_system", "descriptions"));
  }
}

void Interlock::changeStatView(int index)
{
  QString devName = device_name;
  QString attname = QString("Stat_mod_%1").arg(index);
  QString src = devName + "/" + attname; 
  ui.tableStates->setSource(src);
  ui.tableStates->setDescriptions(getProperty(attname.toStdString(), "descriptions"));
}

